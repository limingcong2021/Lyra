name: 自动部署 Pages 和 Worker

on:
  push:
    branches:
      - main  # 在推送到main分支时触发
    tags:
      - '*'   # 在创建标签时触发
  workflow_dispatch:  # 允许手动触发

# 定义环境变量
env:
  # 构建相关路径
  DOWNLOAD_RELEASE_TEMP_PATH: ${{ github.workspace }}/modloader-temp
  
  # HTML 文件配置
  MODLOADER_HTML_NORMAL_FILENAME: "dol.html"
  MODLOADER_HTML_POLYFILL_FILENAME: "dol-polyfill.html"
  
  # Manifest 配置
  MANIFEST_JSON_NORMAL_FILENAME: "manifest-normal.json"
  MANIFEST_JSON_POLYFILL_FILENAME: "manifest-polyfill.json"
  
  # Artifact 配置
  UPLOAD_ARTIFACT_NAME: "ModLoader-Artifact"
  UPLOAD_ARTIFACT_FILEPATH: ${{ github.workspace }}/Modloader-Artifact.zip
  
  # Worker 配置
  WORKER_SCRIPT_PATH: ".github/workers/signaling-server.js"  # 假设Worker脚本位于此处
  WORKER_NAME: "dol-lyra-signaling-worker"  # Cloudflare Worker名称

jobs:
  # 1. 构建阶段
  build:
    runs-on: ubuntu-latest
    
    # 启用详细日志
    env:
      ACTIONS_RUNNER_DEBUG: true
      ACTIONS_STEP_DEBUG: true
    
    steps:
      # 克隆代码仓库
      - name: 克隆代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史记录用于部署验证
      
      # 设置Node.js环境（用于后续测试）
      - name: 设置Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      # 创建临时目录
      - name: 创建构建目录
        run: |
          mkdir -p "${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}"
          echo "构建目录创建成功: ${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}"
      
      # 下载DoL正常版本
      - name: 下载DoL正常版本
        id: getRelease
        uses: robinraju/release-downloader@v1.12
        with:
          repository: "DoL-Lyra/Lyra"
          latest: true
          fileName: "DoL-*-Lyra-*-besc-cheat-csd-*.zip"
          extract: false
          token: ${{ github.token }}
      
      # 下载DoL Polyfill版本
      - name: 下载DoL Polyfill版本
        id: getRelease-polyfill
        uses: robinraju/release-downloader@v1.12
        with:
          repository: "DoL-Lyra/Lyra"
          latest: true
          fileName: "DoL-*-Lyra-*-polyfill-besc-cheat-csd-*.zip"
          extract: false
          token: ${{ github.token }}
      
      # 解压并准备文件
      - name: 解压构建文件
        run: |
          echo "下载的DoL正常版本: ${{ steps.getRelease.outputs.tag_name }}"
          unzip -q ${{ fromJson(steps.getRelease.outputs.downloaded_files)[0] }} -d ${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}
          mv "${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}/Degrees of Lewdity.html" "${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}/${{ env.MODLOADER_HTML_NORMAL_FILENAME }}"

          echo "下载的DoL Polyfill版本: ${{ steps.getRelease-polyfill.outputs.tag_name }}"
          unzip -qo ${{ fromJson(steps.getRelease-polyfill.outputs.downloaded_files)[0] }} -d ${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}
          mv "${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}/Degrees of Lewdity.html" "${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}/${{ env.MODLOADER_HTML_POLYFILL_FILENAME }}"
          
          echo "文件解压完成"
      
      # 复制PWA资源
      - name: 复制PWA资源
        run: |
          cp -r .github/pwa/* ${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}
          echo "PWA资源复制完成"
      
      # 修改HTML文件，添加PWA支持
      - name: 修改HTML文件
        shell: python3 {0}
        run: |
          import os
          for html_name, manifest_name in zip(
            ["${{ env.MODLOADER_HTML_NORMAL_FILENAME }}", "${{ env.MODLOADER_HTML_POLYFILL_FILENAME }}"],
            ["${{ env.MANIFEST_JSON_NORMAL_FILENAME }}", "${{ env.MANIFEST_JSON_POLYFILL_FILENAME }}"]
          ):
            html_path = f"${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}/{html_name}"
            if not os.path.exists(html_path):
                print(f"警告: HTML文件不存在 - {html_path}")
                continue
                
            with open(html_path, "r+", encoding="utf-8") as index_html_file:
              index_html = index_html_file.read()
              insert_index = index_html.find('<meta charset="UTF-8" />')
              if insert_index != -1:
                  index_html = index_html[:insert_index] + f"<link rel=\"manifest\" href=\"{manifest_name}\">\n" + index_html[insert_index:]
              else:
                  print(f"警告: 未找到插入点 - <meta charset=\"UTF-8\" />")
              
              insert_index = index_html.find('<body>\n\t<div id="init-screen">') + 7
              if insert_index > 6:
                  index_html = index_html[:insert_index] + \
                      "    <script>\n" + \
                      "        if (typeof navigator.serviceWorker !== 'undefined') {\n" + \
                      "            navigator.serviceWorker.register('sw.js')\n" + \
                      "        }\n" + \
                      "    </script>\n" + index_html[insert_index:]
              else:
                  print(f"警告: 未找到插入点 - <body>\n\t<div id=\"init-screen\">")
              
              index_html_file.seek(0)
              index_html_file.truncate()
              index_html_file.write(index_html)
          print("HTML文件修改完成")
      
      # 打包构建产物
      - name: 打包构建产物
        run: |
          7z a ${{ env.UPLOAD_ARTIFACT_FILEPATH }} ${{ env.DOWNLOAD_RELEASE_TEMP_PATH }}/*
          echo "构建产物打包完成: ${{ env.UPLOAD_ARTIFACT_FILEPATH }}"
      
      # 上传构建产物
      - name: 上传构建产物
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.UPLOAD_ARTIFACT_NAME }}
          path: ${{ env.UPLOAD_ARTIFACT_FILEPATH }}
          retention-days: 7  # 保留7天

  # 2. 测试阶段
  test:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: 克隆代码
        uses: actions/checkout@v4
      
      - name: 设置Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: 安装测试依赖
        run: |
          npm install --save-dev jest html-validate
          echo "测试依赖安装完成"
      
      - name: 下载构建产物
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.UPLOAD_ARTIFACT_NAME }}
      
      - name: 解压构建产物
        run: |
          unzip -q ${{ env.UPLOAD_ARTIFACT_FILEPATH }} -d ./test-deploy
          echo "构建产物解压完成，开始测试"
      
      - name: 验证HTML文件
        run: |
          # 简单测试文件是否存在
          if [ -f "./test-deploy/${{ env.MODLOADER_HTML_NORMAL_FILENAME }}" ] && [ -f "./test-deploy/${{ env.MODLOADER_HTML_POLYFILL_FILENAME }}" ]; then
            echo "HTML文件存在验证通过"
          else
            echo "错误: HTML文件不存在"
            exit 1
          fi
          
          # 简单验证manifest文件是否存在
          if [ -f "./test-deploy/${{ env.MANIFEST_JSON_NORMAL_FILENAME }}" ] && [ -f "./test-deploy/${{ env.MANIFEST_JSON_POLYFILL_FILENAME }}" ]; then
            echo "Manifest文件存在验证通过"
          else
            echo "错误: Manifest文件不存在"
            exit 1
          fi
      
      - name: 验证Worker脚本（如果存在）
        run: |
          if [ -f "${{ env.WORKER_SCRIPT_PATH }}" ]; then
            echo "Worker脚本存在验证通过"
            # 简单语法检查
            node -c "${{ env.WORKER_SCRIPT_PATH }}"
            echo "Worker脚本语法检查通过"
          else
            echo "警告: Worker脚本不存在 - ${{ env.WORKER_SCRIPT_PATH }}"
          fi

  # 3. 部署Pages阶段
  deploy-pages:
    runs-on: ubuntu-latest
    needs: test
    environment: production
    outputs:
      has_deployed_html: ${{ steps.deploy_html.outputs.success }}
      has_deployed_worker: ${{ steps.check_worker.outputs.exists }}
      pages_deploy_status: ${{ steps.deploy_cloudflare.outcome }}
      has_cf_pages_deploy: ${{ steps.debug_cf_token.outputs.has_token == 'true' }}
    steps:
      - name: 克隆代码
        uses: actions/checkout@v4
      
      - name: 下载构建产物
        uses: actions/download-artifact@v4
        with:
          name: ${{ env.UPLOAD_ARTIFACT_NAME }}
      
      - name: 解压构建产物
        run: |
          mkdir -p ./modloader-temp
          unzip -q ${{ env.UPLOAD_ARTIFACT_FILEPATH }} -d ./modloader-temp
          echo "构建产物解压完成，准备部署"
      
      # 修改manifest配置以适应部署环境
      - name: 修改manifest配置
        shell: python3 {0}
        run: |
          import json
          import os
          
          for manifest_name in ["${{ env.MANIFEST_JSON_NORMAL_FILENAME }}", "${{ env.MANIFEST_JSON_POLYFILL_FILENAME }}"]:
            manifest_path = f"./modloader-temp/{manifest_name}"
            if not os.path.exists(manifest_path):
                print(f"警告: Manifest文件不存在 - {manifest_path}")
                continue
                
            with open(manifest_path, "r+", encoding="utf-8") as manifest_file:
              manifest_json = json.loads(manifest_file.read())
              # 更新路径配置为相对路径
              manifest_json["scope"] = "/"
              manifest_json["start_url"] = "/"
              
              # 更新快捷方式URL为相对路径
              if "shortcuts" in manifest_json and len(manifest_json["shortcuts"]) > 0:
                  manifest_json["shortcuts"][0]["url"] = "/"
              
              # 更新图标路径为相对路径
              if "icons" in manifest_json and len(manifest_json["icons"]) > 0:
                  manifest_json["icons"][0]["src"] = "/icon.png"
              
              # 写入更新后的配置
              manifest_file.seek(0)
              manifest_file.truncate()
              manifest_file.write(json.dumps(manifest_json, indent=2))
          print("Manifest配置修改完成")
      
      # 部署到GitHub Pages
      - name: 部署到GitHub Pages
        id: deploy_github
        uses: crazy-max/ghaction-github-pages@v4
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          build_dir: ./modloader-temp
          keep_history: false
          target_branch: gh-pages
      
      # 添加调试信息显示密钥是否存在（安全方式）
      - name: 调试Cloudflare API Token存在性
        id: debug_cf_token
        run: |
          # 安全地检查密钥是否存在，只输出长度而不是实际值
          TOKEN_LENGTH=$(expr length "${{ secrets.CF_PAGES_API_TOKEN }}")
          if [ $TOKEN_LENGTH -gt 0 ]; then
            echo "调试信息: CF_PAGES_API_TOKEN 存在，长度: $TOKEN_LENGTH 字符"
            echo "token_exists=true" >> $GITHUB_OUTPUT
          else
            echo "调试信息: CF_PAGES_API_TOKEN 不存在或为空"
            echo "token_exists=false" >> $GITHUB_OUTPUT
          fi
          
          # 检查环境变量
          if [ -n "${{ secrets.CF_PAGES_API_TOKEN }}" ]; then
            echo "has_token=true" >> $GITHUB_OUTPUT
          else
            echo "has_token=false" >> $GITHUB_OUTPUT
          fi
      
      # 部署到Cloudflare Pages（仅当环境变量存在时）
      - name: 部署到Cloudflare Pages
        id: deploy_cloudflare
        if: steps.debug_cf_token.outputs.has_token == 'true'
        uses: cloudflare/pages-action@v1
        with:
          apiToken: ${{ secrets.CF_PAGES_API_TOKEN }}
          projectName: "degrees-of-lewdity"
          directory: "./modloader-temp"
      
      # 输出部署信息
      - name: 输出部署信息
        run: |
          echo "=== 部署信息 ==="
          echo "GitHub Pages 部署状态: ${{ steps.deploy_github.outcome }}"
          echo "Cloudflare Pages 部署状态: ${{ steps.deploy_cloudflare.outcome }}"
          echo "部署提交: ${{ github.sha }}"
          echo "部署分支: ${{ github.ref }}"
          echo "部署时间: $(date)"

  # 4. 部署Worker阶段
  deploy-worker:
    runs-on: ubuntu-latest
    needs: test
    environment: production
    steps:
      - name: 克隆代码
        uses: actions/checkout@v4
      
      - name: 检查并调试环境变量
        id: check_env
        run: |
          # 安全地检查CF_PAGES_API_TOKEN是否存在
          TOKEN_LENGTH=$(expr length "${{ secrets.CF_PAGES_API_TOKEN }}")
          if [ $TOKEN_LENGTH -gt 0 ]; then
            echo "调试信息: CF_PAGES_API_TOKEN 存在，长度: $TOKEN_LENGTH 字符"
            echo "has_token=true" >> $GITHUB_OUTPUT
          else
            echo "调试信息: CF_PAGES_API_TOKEN 不存在或为空"
            echo "has_token=false" >> $GITHUB_OUTPUT
          fi
          
          # 安全地检查CF_ACCOUNT_ID是否存在
          ACCOUNT_ID_LENGTH=$(expr length "${{ secrets.CF_ACCOUNT_ID }}")
          if [ $ACCOUNT_ID_LENGTH -gt 0 ]; then
            echo "调试信息: CF_ACCOUNT_ID 存在，长度: $ACCOUNT_ID_LENGTH 字符"
            echo "has_account=true" >> $GITHUB_OUTPUT
          else
            echo "调试信息: CF_ACCOUNT_ID 不存在或为空"
            echo "has_account=false" >> $GITHUB_OUTPUT
          fi
      
      - name: 检查Worker脚本是否存在
        id: check_worker
        run: |
          if [ -f "${{ env.WORKER_SCRIPT_PATH }}" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Worker脚本存在，准备部署"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "警告: Worker脚本不存在，跳过部署"
          fi
      
      # 检查Worker脚本语法（仅当脚本存在时）
      - name: 检查Worker脚本语法
        if: steps.check_worker.outputs.exists == 'true'
        run: |
          echo "检查Worker脚本语法..."
          # 使用Node.js的语法检查模式，依赖package.json中的"type": "module"配置
          node --check ${{ env.WORKER_SCRIPT_PATH }} || {
            echo "Worker脚本语法检查失败！"
            exit 1
          }
          echo "Worker脚本语法检查通过"
      
      # 仅当Worker脚本存在且环境变量设置完整时执行部署
      - name: 部署Cloudflare Worker
        id: deploy_worker
        if: steps.check_worker.outputs.exists == 'true' && steps.check_env.outputs.has_token == 'true' && steps.check_env.outputs.has_account == 'true'
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CF_PAGES_API_TOKEN }}
          accountId: ${{ secrets.CF_ACCOUNT_ID }}
          command: deploy
          workingDirectory: ${{ github.workspace }}/.github/workers
          wranglerVersion: 'latest'
      
      # 输出Worker部署信息
      - name: 输出Worker部署信息
        if: steps.check_worker.outputs.exists == 'true' && steps.check_env.outputs.has_token == 'true' && steps.check_env.outputs.has_account == 'true'
        run: |
          echo "=== Worker部署信息 ==="
          echo "Worker名称: ${{ env.WORKER_NAME }}"
          echo "部署时间: $(date)"

  # 5. 部署验证阶段
  verify-deployment:
    runs-on: ubuntu-latest
    needs: [deploy-pages, deploy-worker]
    if: always()  # 即使前面的作业失败也运行
    steps:
      - name: 等待部署完成
        run: |
          echo "等待部署生效..."
          sleep 30  # 给部署一些时间生效
      
      - name: 设置Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
      
      - name: 安装验证工具
        run: npm install -g axios
      
      # 验证GitHub Pages部署
      - name: 验证GitHub Pages部署
        id: verify_github_pages
        continue-on-error: true  # 即使验证失败也继续
        run: |
          # 更新为使用当前仓库的gh-pages分支的URL
          PAGES_URL="https://${{ github.repository_owner }}.github.io/${{ github.event.repository.name }}/${{ env.MODLOADER_HTML_NORMAL_FILENAME }}"
          echo "验证GitHub Pages URL: $PAGES_URL"
          
          # 简单的HTTP状态检查
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$PAGES_URL")
          if [ "$STATUS_CODE" -eq 200 ] || [ "$STATUS_CODE" -eq 301 ] || [ "$STATUS_CODE" -eq 302 ]; then
            echo "GitHub Pages 验证通过，状态码: $STATUS_CODE"
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "警告: GitHub Pages 验证失败，状态码: $STATUS_CODE"
            echo "success=false" >> $GITHUB_OUTPUT
          fi
      
      # 验证Cloudflare Pages部署（仅当部署实际执行时）
      - name: 验证Cloudflare Pages部署
        id: verify_cloudflare_pages
        if: ${{ needs.deploy-pages.result == 'success' }}
        continue-on-error: true
        run: |
          # 检查部署是否实际执行
          if [ "${{ needs.deploy-pages.outputs.has_cf_pages_deploy }}" != "true" ]; then
            echo "Cloudflare Pages部署未执行，跳过验证"
            echo "success=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # 假设Cloudflare Pages URL格式
          CF_URL="https://degrees-of-lewdity.pages.dev/${{ env.MODLOADER_HTML_NORMAL_FILENAME }}"
          echo "验证Cloudflare Pages URL: $CF_URL"
          
          STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$CF_URL")
          if [ "$STATUS_CODE" -eq 200 ] || [ "$STATUS_CODE" -eq 301 ] || [ "$STATUS_CODE" -eq 302 ]; then
            echo "Cloudflare Pages 验证通过，状态码: $STATUS_CODE"
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "警告: Cloudflare Pages 验证失败，状态码: $STATUS_CODE"
            echo "success=false" >> $GITHUB_OUTPUT
          fi
      
      # 生成部署报告
      - name: 生成部署报告
        run: |
          echo "==========================="
          echo "    部署验证报告"
          echo "==========================="
          echo "部署提交: ${{ github.sha }}"
          echo "部署分支: ${{ github.ref }}"
          echo "部署时间: $(date)"
          echo "---------------------------"
          echo "GitHub Pages 状态: ${{ steps.verify_github_pages.outputs.success == 'true' && '成功' || '失败' }}"
          echo "Cloudflare Pages 状态: ${{ steps.verify_cloudflare_pages.outputs.success == 'true' && '成功' || '失败' }}"
          echo "==========================="
          
          # 检查是否有部署失败
          if [ "${{ steps.verify_github_pages.outputs.success }}" = "false" ] && [ "${{ steps.verify_cloudflare_pages.outputs.success }}" = "false" ]; then
            echo "错误: 所有部署验证都失败了"
            exit 1
          fi

  # 6. 清理阶段
  cleanup:
    runs-on: ubuntu-latest
    if: always()
    needs: [build, test, deploy-pages, deploy-worker, verify-deployment]
    steps:
      - name: 清理构建产物
        uses: geekyeggo/delete-artifact@v4
        with:
          name: ${{ env.UPLOAD_ARTIFACT_NAME }}
      
      - name: 记录部署完成
        run: |
          echo "部署流程完成，时间: $(date)"
          echo "部署总结:"
          echo "- 构建: ${{ needs.build.result }}"
          echo "- 测试: ${{ needs.test.result }}"
          echo "- Pages部署: ${{ needs.deploy-pages.result }}"
          echo "- Worker部署: ${{ needs.deploy-worker.result }}"
          echo "- 部署验证: ${{ needs.verify-deployment.result }}"